#include <vector>
#include <boost/log/trivial.hpp>
#include <boost/functional/hash.hpp>

#include "AgreeSetMiner.h"
#include "BoostUtil.h"
#include "VectorUtil.h"

using namespace std;

//----------------- IndexSet ------------------------------

IndexSet indexSetOf(const AttributeSet &x)
{
    IndexSet result;
    for ( size_t i = 0; i < x.size(); ++i )
        if ( x[i] )
            result.push_back(i);
    return result;
}

//----------------- ClosureCalculator ---------------------

ClosureCalculator::ClosureCalculator(const Table &table, size_t columnCount) : table(table), columnCount(columnCount ? columnCount : table[0].size())
{
}

size_t ClosureCalculator::subHash(const Row &row, const IndexSet &x)
{
    size_t seed = 0;
    for ( size_t index : x )
        // see https://stackoverflow.com/questions/19966041/getting-too-many-collisions-with-hash-combine
        boost::hash_combine(seed, row[index] * 2654435761);
    return seed;
}

AttributeSet ClosureCalculator::operator()(const AttributeSet &x)
{
    size_t xHash = boost::hash_value(x);
    if ( memo.count(xHash) )
    {
        BOOST_LOG_TRIVIAL(trace) << "closure(" << x << ") = " << memo[xHash] << " (memoized via " << xHash << ")";
        return memo[xHash];
    }
    // hash rows based on values in x & sort by hash
    struct RowRef
    {
        const Row *row;
        size_t hashValue;
        bool operator<(const RowRef &other) { return hashValue < other.hashValue; }
    };
    vector<RowRef> rowRefs(table.size());
    IndexSet columnSet = indexSetOf(x);
    for ( size_t i = 0; i < table.size(); i++ )
    {
        rowRefs[i].row = &table[i];
        rowRefs[i].hashValue = subHash(table[i], columnSet);
    }
    sort(rowRefs.begin(), rowRefs.end());
    // compute closure
    AttributeSet closure(columnCount);
    closure.flip();
    for ( size_t i = 1; i < table.size(); i++ )
        if ( rowRefs[i].hashValue == rowRefs[i-1].hashValue )
        {
            BOOST_LOG_TRIVIAL(trace) << "closure(" << x << "): comparing\n" << *rowRefs[i-1].row << " with\n" << *rowRefs[i].row;
            for ( size_t col = 0; col < columnCount; col++ )
                if ( closure[col] )
                    closure[col] = rowRefs[i].row->at(col) == rowRefs[i-1].row->at(col);
            assert( x.is_subset_of(closure) );
        }
    memo[xHash] = closure;
    BOOST_LOG_TRIVIAL(trace) << __FUNCTION__ << "(" << x << ") = " << closure;
    return closure;
}

size_t ClosureCalculator::columns() const
{
    return columnCount;
}

//----------------- main functions ------------------------

bool containsSubset(const vector<AttributeSet> &attSets, const AttributeSet &x)
{
    for ( const AttributeSet &y : attSets )
        if ( y.is_subset_of(x) )
            return true;
    return false;
}

// see http://sites.computer.org/debull/A16june/p21.pdf, section 6.1 for core idea
vector<AttributeSet> getMaxAntiLhs(size_t rhs, ClosureCalculator &closure)
{
    size_t columns = closure.columns();
    vector<AttributeSet> maxAntiLhs;
    vector<AttributeSet> trans = { AttributeSet(columns) }; // transversal of maxLhs
    while ( !trans.empty() )
    {
        AttributeSet x = trans.back();
        AttributeSet cl = closure(x);
        if ( cl[rhs] )
        {
            // just discard it - any future super-set generated by x won't be anti-lhs
            trans.pop_back();
        }
        else
        {
            // maximize x, starting with cl
            x = cl;
            for ( size_t c = 0; c < columns; c++ )
                if ( c != rhs && !x[c] )
                {
                    x[c] = true;
                    cl = closure(x);
                    if ( cl[rhs] )
                        x[c] = false;
                    else
                        x = cl;
                }
            // we found a new maximal anti-LHS
            maxAntiLhs.push_back(x);
            BOOST_LOG_TRIVIAL(debug) << __FUNCTION__ << "(" << rhs << "): " << x;
            // update transversal
            AttributeSet xComplement(x);
            xComplement.flip().set(rhs, false);
            IndexSet xCompVec = indexSetOf(xComplement);
            vector<AttributeSet> newTrans;
            unordered_set<size_t> newTransSet;
            size_t next = 0;
            while ( next < trans.size() )
            {
                AttributeSet &t = trans[next];
                if ( !t.intersects(xComplement) )
                {
                    // extend to new transversal values
                    for ( size_t att : xCompVec )
                    {
                        AttributeSet tExtended(t);
                        tExtended.set(att);
                        size_t tExtHash = boost::hash_value(tExtended);
                        if ( !newTransSet.count(tExtHash) )
                        {
                            newTrans.push_back(tExtended);
                            newTransSet.insert(tExtHash);
                        }
                    }
                    // remove from trans
                    t = trans.back();
                    trans.pop_back();
                }
                else
                    next++;
            }
            // minimize transversal - only new transversals need to be checked
            while ( !newTrans.empty() )
            {
                const AttributeSet tNew = newTrans.back(); newTrans.pop_back();
                if ( !containsSubset(trans, tNew) && !containsSubset(newTrans, tNew) )
                    trans.push_back(tNew);
            }
        }
        BOOST_LOG_TRIVIAL(trace) << __FUNCTION__ << "(" << rhs << "): trans = " << trans;
    }
    return maxAntiLhs;
}

vector<AttributeSet> getGenerators(ClosureCalculator &closure)
{
    size_t columns = closure.columns();
    unordered_set<AttributeSet> generators;
    for ( size_t rhs = 0; rhs < columns; ++rhs )
        for ( AttributeSet const& antiLhs : getMaxAntiLhs(rhs, closure) )
            generators.insert(antiLhs);
    vector<AttributeSet> result;
    result.insert(result.end(), generators.begin(), generators.end());
    return result;
}
