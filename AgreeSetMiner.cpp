#include <bits/stdc++.h>
#include <boost/hash.hpp>
#include <boost/dynamic_bitset.hpp>

using namespace std;

typedef vector<size_t> Row;
typedef vector<Row> Table;
typedef boost::dynamic_bitset<> AttSet;

namespace std
{
    template <typename Block, typename Alloc> struct hash<boost::dynamic_bitset<Block, Alloc>>
    {
        size_t operator()(boost::dynamic_bitset<Block, Alloc> const& bs) const
        {
            size_t seed = 0;
            std::vector<Block> blocks(bs.num_blocks());
            to_block_range(bs, blocks.begin());
            boost::hash_range(seed, blocks.begin(), blocks.end());
            return seed;
        }
    };
}

//----------------- ClosureCalculator ---------------------

class ClosureCalculator
{
    const Table &table;
    const size_t columnCount;
    map<size_t, AttSet> memo;

    typedef vector<size_t> IndexSet;

    static IndexSet indexSetOf(const AttSet &x);
    static size_t subHash(const Row &row, const IndexSet &x);
public:
    ClosureCalculator(const Table &table, size_t columnCount = 0) : table(table), columnCount(columnCount ? columnCount : table[0].size()) {}
    AttSet operator()(const AttSet &x);
    size_t columns() const { return columnCount; }
};

size_t ClosureCalculator::subHash(const Row &row, const IndexSet &x)
{
    size_t seed = 0;
    for ( size_t index : x )
        boost::hash_combine(seed, row[index]);
    return seed;
}

IndexSet ClosureCalculator::indexSetOf(const AttSet &x)
{
    IndexSet result;
    for ( size_t i = 0; i < x.size(); ++i )
        if ( x[i] )
            result.push_back(i);
    return result;
}

AttSet ClosureCalculator::operator()(const AttSet &x)
{
    size_t xHash = hash(x);
    if ( memo.count(xHash) )
        return memo[xHash];
    // hash rows based on values in x & sort by hash
    struct RowRef
    {
        const Row &row;
        size_t hashValue;
        operator<(const RowRef &other) { return hashValue < other.hashValue; }
    };
    vector<RowRef> rowRefs(table.size());
    IndexSet columnSet = indexSetOf(x);
    for ( size_t i = 0; i < table.size(); i++ )
    {
        rowRefs[i].row = table[i].row;
        rowRefs[i].hashValue = subHash(table[i].row, columnSet);
    }
    sort(rowRefs);
    // compute closure
    AttSet closure(columnCount);
    closure.flip();
    for ( size_t i = 1; i < table.size(); i++ )
        if ( rowRefs[i].hashValue == rowRefs[i-1].hashValue )
            for ( size_t col = 0; col < columnCount; col++ )
                closure[col] &= rowRefs[i].row[col] == rowRefs[i-1].row[col];
    memo[xHash] = closure;
    return closure;
}

//----------------- main functions ------------------------

bool containsSubset(const vector<AttSet> &attSets, const AttSet &x)
{
    for ( const AttSet &y : attSets )
        if ( y.is_subset_of(x) )
            return true;
    return false;
}

// see http://sites.computer.org/debull/A16june/p21.pdf, section 6.1 for core idea
vector<AttSet> getMaxAntiLhs(size_t rhs, ClosureCalculator &closure)
{
    size_t columns = closure.columns();
    vector<AttSet> maxAntiLhs;
    vector<AttSet> trans = { AttSet(columns) }; // transversal of maxLhs
    while ( !trans.empty() )
    {
        AttSet x = trans.back();
        AttSet cl = closure(x);
        if ( cl[rhs] )
        {
            // just discard it - any future super-set generated by x won't be anti-lhs
            trans.pop_back();
        }
        else
        {
            // maximize x, starting with cl
            x = cl;
            for ( int c = 0; c < columns; c++ )
                if ( c != rhs && !cl[c] )
                {
                    x[c] = true;
                    cl = closure(x);
                    if ( cl[rhs] )
                        x[c] = false;
                }
            // we found a new maximal anti-LHS
            maxAntiLhs.push_back(x);
            // update transversal
            AttSet xComplement(x).flip().set(rhs, false);
            IndexSet xCompVec = indexSetOf(xComplement);
            vector<AttSet> newTrans;
            unordered_set<size_t> newTransSet;
            size_t next = 0;
            while ( next < trans.size() )
            {
                AttSet &t = trans[next];
                if ( !t.intersects(xComplement) )
                {
                    // extend to new transversal values
                    for ( size_t att : xCompVec )
                    {
                        AttSet tExtended(t).set(att);
                        size_t tExtHash = hash(tExtended);
                        if ( !newTransSet.count(tExtHash) )
                        {
                            newTrans.push_back(tExtended);
                            newTransSet.insert(tExtHash);
                        }
                    }
                    // remove from trans
                    t = trans.back();
                    trans.pop_back();
                }
                else
                    next++;
            }
            // minimize transversal - only new transversals need to be checked
            while ( !newTrans.empty() )
            {
                const AttSet tNew = newTrans.back(); newTrans.pop_back();
                if ( !containsSubset(trans, tNew) && !containsSubset(newTrans, tNew) )
                    trans.push_back(tNew);
            }
        }
    }
    return maxAntiLhs;
}

int main()
{
}
