#include <bits/stdc++.h>
#include <boost/functional/hash.hpp>
#include <boost/dynamic_bitset.hpp>
#include <boost/tokenizer.hpp>

using namespace std;

typedef vector<size_t> Row;
typedef vector<Row> Table;
typedef boost::dynamic_bitset<> AttSet;

// implement hash function for dynamic_bitset (still not part of boost)
namespace boost {
    template <typename Block, typename Alloc>
    std::size_t hash_value(boost::dynamic_bitset<Block, Alloc> const& bs)
    {
        size_t seed = 0;
        std::vector<Block> blocks(bs.num_blocks());
        to_block_range(bs, blocks.begin());
        boost::hash_range(seed, blocks.begin(), blocks.end());
        return seed;
    }
}

//----------------- IndexSet ------------------------------

typedef vector<size_t> IndexSet;

IndexSet indexSetOf(const AttSet &x)
{
    IndexSet result;
    for ( size_t i = 0; i < x.size(); ++i )
        if ( x[i] )
            result.push_back(i);
    return result;
}

//----------------- ClosureCalculator ---------------------

typedef vector<size_t> IndexSet;


class ClosureCalculator
{
    const Table &table;
    const size_t columnCount;
    map<size_t, AttSet> memo;

    static size_t subHash(const Row &row, const IndexSet &x);
public:
    ClosureCalculator(const Table &table, size_t columnCount = 0) : table(table), columnCount(columnCount ? columnCount : table[0].size()) {}
    AttSet operator()(const AttSet &x);
    size_t columns() const { return columnCount; }
};

size_t ClosureCalculator::subHash(const Row &row, const IndexSet &x)
{
    size_t seed = 0;
    for ( size_t index : x )
        boost::hash_combine(seed, row[index]);
    return seed;
}

AttSet ClosureCalculator::operator()(const AttSet &x)
{
    size_t xHash = boost::hash_value(x);
    if ( memo.count(xHash) )
        return memo[xHash];
    // hash rows based on values in x & sort by hash
    struct RowRef
    {
        const Row *row;
        size_t hashValue;
        bool operator<(const RowRef &other) { return hashValue < other.hashValue; }
    };
    vector<RowRef> rowRefs(table.size());
    IndexSet columnSet = indexSetOf(x);
    for ( size_t i = 0; i < table.size(); i++ )
    {
        rowRefs[i].row = &table[i];
        rowRefs[i].hashValue = subHash(table[i], columnSet);
    }
    sort(rowRefs.begin(), rowRefs.end());
    // compute closure
    AttSet closure(columnCount);
    closure.flip();
    for ( size_t i = 1; i < table.size(); i++ )
        if ( rowRefs[i].hashValue == rowRefs[i-1].hashValue )
            for ( size_t col = 0; col < columnCount; col++ )
                closure[col] &= rowRefs[i].row->at(col) == rowRefs[i-1].row->at(col);
    memo[xHash] = closure;
    return closure;
}

//----------------- main functions ------------------------

bool containsSubset(const vector<AttSet> &attSets, const AttSet &x)
{
    for ( const AttSet &y : attSets )
        if ( y.is_subset_of(x) )
            return true;
    return false;
}

// see http://sites.computer.org/debull/A16june/p21.pdf, section 6.1 for core idea
vector<AttSet> getMaxAntiLhs(size_t rhs, ClosureCalculator &closure)
{
    size_t columns = closure.columns();
    vector<AttSet> maxAntiLhs;
    vector<AttSet> trans = { AttSet(columns) }; // transversal of maxLhs
    while ( !trans.empty() )
    {
        AttSet x = trans.back();
        AttSet cl = closure(x);
        if ( cl[rhs] )
        {
            // just discard it - any future super-set generated by x won't be anti-lhs
            trans.pop_back();
        }
        else
        {
            // maximize x, starting with cl
            x = cl;
            for ( size_t c = 0; c < columns; c++ )
                if ( c != rhs && !cl[c] )
                {
                    x[c] = true;
                    cl = closure(x);
                    if ( cl[rhs] )
                        x[c] = false;
                }
            // we found a new maximal anti-LHS
            maxAntiLhs.push_back(x);
            // update transversal
            AttSet xComplement(x);
            xComplement.flip().set(rhs, false);
            IndexSet xCompVec = indexSetOf(xComplement);
            vector<AttSet> newTrans;
            unordered_set<size_t> newTransSet;
            size_t next = 0;
            while ( next < trans.size() )
            {
                AttSet &t = trans[next];
                if ( !t.intersects(xComplement) )
                {
                    // extend to new transversal values
                    for ( size_t att : xCompVec )
                    {
                        AttSet tExtended(t);
                        tExtended.set(att);
                        size_t tExtHash = boost::hash_value(tExtended);
                        if ( !newTransSet.count(tExtHash) )
                        {
                            newTrans.push_back(tExtended);
                            newTransSet.insert(tExtHash);
                        }
                    }
                    // remove from trans
                    t = trans.back();
                    trans.pop_back();
                }
                else
                    next++;
            }
            // minimize transversal - only new transversals need to be checked
            while ( !newTrans.empty() )
            {
                const AttSet tNew = newTrans.back(); newTrans.pop_back();
                if ( !containsSubset(trans, tNew) && !containsSubset(newTrans, tNew) )
                    trans.push_back(tNew);
            }
        }
    }
    return maxAntiLhs;
}

int main()
{
    string s = "Field 1,\"putting quotes around fields, allows commas\",Field 3";
    boost::tokenizer<boost::escaped_list_separator<char>> tok(s);
    for ( auto it = tok.begin(); it != tok.end(); ++it )
    {
        cout << *it << "\n";
    }
}
