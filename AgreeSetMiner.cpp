#include <bits/stdc++.h>
#include <boost/log/trivial.hpp>
#include <boost/functional/hash.hpp>

#include "AgreeSetMiner.h"
#include "BoostUtil.h"

//----------------- IndexSet ------------------------------

IndexSet indexSetOf(const AttSet &x)
{
    IndexSet result;
    for ( size_t i = 0; i < x.size(); ++i )
        if ( x[i] )
            result.push_back(i);
    return result;
}

//----------------- ClosureCalculator ---------------------

ClosureCalculator::ClosureCalculator(const Table &table, size_t columnCount) : table(table), columnCount(columnCount ? columnCount : table[0].size())
{
}

size_t ClosureCalculator::subHash(const Row &row, const IndexSet &x)
{
    size_t seed = 0;
    for ( size_t index : x )
        boost::hash_combine(seed, row[index]);
    return seed;
}

AttSet ClosureCalculator::operator()(const AttSet &x)
{
    size_t xHash = boost::hash_value(x);
    if ( memo.count(xHash) )
        return memo[xHash];
    // hash rows based on values in x & sort by hash
    struct RowRef
    {
        const Row *row;
        size_t hashValue;
        bool operator<(const RowRef &other) { return hashValue < other.hashValue; }
    };
    vector<RowRef> rowRefs(table.size());
    IndexSet columnSet = indexSetOf(x);
    for ( size_t i = 0; i < table.size(); i++ )
    {
        rowRefs[i].row = &table[i];
        rowRefs[i].hashValue = subHash(table[i], columnSet);
    }
    sort(rowRefs.begin(), rowRefs.end());
    // compute closure
    AttSet closure(columnCount);
    closure.flip();
    for ( size_t i = 1; i < table.size(); i++ )
        if ( rowRefs[i].hashValue == rowRefs[i-1].hashValue )
            for ( size_t col = 0; col < columnCount; col++ )
                closure[col] &= rowRefs[i].row->at(col) == rowRefs[i-1].row->at(col);
    memo[xHash] = closure;
    return closure;
}

size_t ClosureCalculator::columns() const
{
    return columnCount;
}

//----------------- main functions ------------------------

bool containsSubset(const vector<AttSet> &attSets, const AttSet &x)
{
    for ( const AttSet &y : attSets )
        if ( y.is_subset_of(x) )
            return true;
    return false;
}

// see http://sites.computer.org/debull/A16june/p21.pdf, section 6.1 for core idea
vector<AttSet> getMaxAntiLhs(size_t rhs, ClosureCalculator &closure)
{
    size_t columns = closure.columns();
    vector<AttSet> maxAntiLhs;
    vector<AttSet> trans = { AttSet(columns) }; // transversal of maxLhs
    while ( !trans.empty() )
    {
        AttSet x = trans.back();
        AttSet cl = closure(x);
        if ( cl[rhs] )
        {
            // just discard it - any future super-set generated by x won't be anti-lhs
            trans.pop_back();
        }
        else
        {
            // maximize x, starting with cl
            x = cl;
            for ( size_t c = 0; c < columns; c++ )
                if ( c != rhs && !x[c] )
                {
                    x[c] = true;
                    cl = closure(x);
                    if ( cl[rhs] )
                        x[c] = false;
                    else
                        x = cl;
                }
            // we found a new maximal anti-LHS
            maxAntiLhs.push_back(x);
            BOOST_LOG_TRIVIAL(debug) << __FUNCTION__ << "(" << rhs << "): " << x;
            // update transversal
            AttSet xComplement(x);
            xComplement.flip().set(rhs, false);
            IndexSet xCompVec = indexSetOf(xComplement);
            vector<AttSet> newTrans;
            unordered_set<size_t> newTransSet;
            size_t next = 0;
            while ( next < trans.size() )
            {
                AttSet &t = trans[next];
                if ( !t.intersects(xComplement) )
                {
                    // extend to new transversal values
                    for ( size_t att : xCompVec )
                    {
                        AttSet tExtended(t);
                        tExtended.set(att);
                        size_t tExtHash = boost::hash_value(tExtended);
                        if ( !newTransSet.count(tExtHash) )
                        {
                            newTrans.push_back(tExtended);
                            newTransSet.insert(tExtHash);
                        }
                    }
                    // remove from trans
                    t = trans.back();
                    trans.pop_back();
                }
                else
                    next++;
            }
            // minimize transversal - only new transversals need to be checked
            while ( !newTrans.empty() )
            {
                const AttSet tNew = newTrans.back(); newTrans.pop_back();
                if ( !containsSubset(trans, tNew) && !containsSubset(newTrans, tNew) )
                    trans.push_back(tNew);
            }
        }
    }
    return maxAntiLhs;
}

vector<AttSet> getGenerators(ClosureCalculator &closure)
{
    size_t columns = closure.columns();
    unordered_set<AttSet> generators;
    for ( size_t rhs = 0; rhs < columns; ++rhs )
        for ( AttSet const& antiLhs : getMaxAntiLhs(rhs, closure) )
            generators.insert(antiLhs);
    vector<AttSet> result;
    result.insert(result.end(), generators.begin(), generators.end());
    return result;
}
